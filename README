# xv6 os

介绍xv6操作系统

# 第一章用户程序

```shell
1.riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2 -DSOL_UTIL -DLAB_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -march=rv64g -nostdinc -I. -Ikernel -c user/initcode.S -o user/initcode.o
2.riscv64-unknown-elf-ld -z max-page-size=4096 -N -e start -Ttext 0 -o user/initcode.out user/initcode.o
3.riscv64-unknown-elf-objcopy -S -O binary user/initcode.out user/initcode
```

从用户的角度进行查看以initcode.S程序为例，每一个用户程序都至少需要经历上面两个步骤。

1. 将源代码编译成目标文件。
1. ld链接成ELF文件的过程，xv6的用户链接脚本是从0虚拟地址开始的。
1. 对于第一个用户程序initcode.S特有的命令直接获取执行的指令，放到proc.c文件中。

第一章需要调用user.h中的system calls来实现各种用户程序。

# 第二章syscall

添加syscall系统调用，获取操作系统的资源查看系统的状态。

记录下从用户层面的syscall的流程
1. 当执行指令ecall之后，pc会跳转到stvec陷入指令的位置，其中pc的值会保存到epc，程序跳转到uservec
1. 然后程序会跳转到usertrap() ---> syscall(). ----> 会根据ecall指令之前设置a7寄存器的值来调用相关的系统调用
1. 完成syscall之后usertrapret(). --->. userret() ---->继续用户程序的执行

# 第三章 

64的虚拟地址空间使用后面的39位 = 9 + 9 + 9 +12 （其中）

PTE(页表项64位)：其中低 54 位 44 + 10 ，44位表示物理内存可以含有多少个页面，10表示当前页面的标识位



